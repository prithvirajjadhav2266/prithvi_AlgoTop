# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": ["NoOp"]}, "methods": [{"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "desc": "Name of the club", "name": "club_name"}, {"type": "string", "desc": "Contact information (email/telegram)", "name": "contact"}], "name": "register_club", "returns": {"type": "string", "desc": "Success message"}, "desc": "Register a new club organization", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "desc": "Name of the event", "name": "event_name"}, {"type": "string", "desc": "Event location", "name": "venue"}, {"type": "uint64", "desc": "Unix timestamp of event date", "name": "event_date"}, {"type": "uint64", "desc": "Price per ticket in microAlgos", "name": "ticket_price"}, {"type": "uint64", "desc": "Total number of tickets available", "name": "ticket_count"}], "name": "create_event", "returns": {"type": "uint64", "desc": "Unique identifier for the created event"}, "desc": "Create a new ticketed event and mint ticket ASAs", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "ID of the event", "name": "event_id"}, {"type": "pay", "desc": "Payment transaction (must be grouped with this call)", "name": "payment"}], "name": "buy_ticket", "returns": {"type": "uint64", "desc": "The ASA ID of the ticket"}, "desc": "Purchase a ticket for an event\nStudent pays ALGO to club, receives ticket ASA", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "ID of the event", "name": "event_id"}, {"type": "account", "desc": "Wallet address to check", "name": "attendee"}], "name": "verify_ticket", "returns": {"type": "bool", "desc": "True if attendee owns a ticket, False otherwise"}, "desc": "Verify if an attendee owns a ticket for an event (for check-in)", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "ID of the event", "name": "event_id"}], "name": "get_event_details", "returns": {"type": "(byte[],byte[],byte[],uint64,uint64,uint64,uint64,uint64)", "desc": "Tuple of (club_owner, event_name, venue, date, price, total, sold, asset_id)"}, "desc": "Get detailed information about an event", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "byte[]", "desc": "Wallet address of the club", "name": "club_address"}], "name": "get_club_name", "returns": {"type": "byte[]", "desc": "Club name as bytes"}, "desc": "Get the name of a registered club", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [], "name": "get_total_events", "returns": {"type": "uint64", "desc": "Total event count"}, "desc": "Get the total number of events created", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "account", "desc": "Wallet address to check", "name": "club_address"}], "name": "is_club_registered", "returns": {"type": "bool", "desc": "True if registered, False otherwise"}, "desc": "Check if an address is a registered club", "events": [], "readonly": true, "recommendations": {}}], "name": "TicketingPlatform", "state": {"keys": {"box": {}, "global": {"event_counter": {"key": "ZXZlbnRfY291bnRlcg==", "keyType": "AVMString", "valueType": "AVMUint64"}}, "local": {}}, "maps": {"box": {"club_names": {"keyType": "address", "valueType": "AVMBytes", "prefix": "Yw=="}, "event_clubs": {"keyType": "uint64", "valueType": "address", "prefix": "ZWM="}, "event_names": {"keyType": "uint64", "valueType": "AVMBytes", "prefix": "ZW4="}, "event_venues": {"keyType": "uint64", "valueType": "AVMBytes", "prefix": "ZXY="}, "event_dates": {"keyType": "uint64", "valueType": "uint64", "prefix": "ZWQ="}, "event_prices": {"keyType": "uint64", "valueType": "uint64", "prefix": "ZXA="}, "event_total": {"keyType": "uint64", "valueType": "uint64", "prefix": "ZXQ="}, "event_sold": {"keyType": "uint64", "valueType": "uint64", "prefix": "ZXM="}, "event_assets": {"keyType": "uint64", "valueType": "uint64", "prefix": "ZWE="}}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 0, "ints": 1}, "local": {"bytes": 0, "ints": 0}}}, "structs": {}, "byteCode": {"approval": "CiACAQAmCwQVH3x1DWV2ZW50X2NvdW50ZXIBYwJlYQJlYwJlcAJldAJlcwJlbgJldgJlZDEYQAADKSNnMRtBAX+CCAS8V6l3BMD/QFAEjiqoPgSNFyIcBIemDPIEItwH5QTekSH/BLyAIJM2GgCOCAEcAPMA1AC6AEcAKQAYAAIjQzEZFEQxGEQ2GgEXwByIAyIoTFCwIkMxGRREMRhEiAMNFihMULAiQzEZFEQxGEQ2GgFXAgCIAuVJFRZXBgJMUChMULAiQzEZFEQxGEQ2GgEXiAKASwcVFlcGAk8IUEsHFRZXBgJPCFBLBxUWVwYCTwhQTwcWTwcWTwcWTwcWTwcWSwcVgS4ISRZXBgKAAgAuTFBLCBVPAggWVwYCUE8FUE8EUE8DUE8CUExQTwNQTwJQTFAoTFCwIkMxGRREMRhENhoBFzYaAhfAHIgB3ihMULAiQzEZFEQxGEQ2GgEXMRYiCUk4ECISRIgBUxYoTFCwIkMxGRREMRhENhoBVwIANhoCVwIANhoDFzYaBBc2GgUXiABrFihMULAiQzEZFEQxGEQ2GgFXAgA2GgJXAgCIABlJFRZXBgJMUChMULAiQzEZQP67MRgURCJDigIBKjEAUL5FARREKjEAUEm8SIv+v4AcQ2x1YiByZWdpc3RlcmVkIHN1Y2Nlc3NmdWxseYmKBQEqMQBQvkUBRIv9MgcNRIv+RIv/RIv/gZBODkQjKWVEIggpTGcjKWVEsTIKRwOyLLIrsiqyKYAXaHR0cHM6Ly9jYW1wdXMtdGl4LmFsZ2+yJ4v7siaAA1RLVLIlI7IkI7Iji/+yIoEDshCBmHWyAbO0PEsBFicESwFQMQC/JwhLAVBJvEiL+78nCUsBUEm8SIv8vycKSwFQi/0WvycFSwFQi/4WvycGSwFQi/8WvycHSwFQIxa/K0xQTBa/iYoCAYv+FicESwFQvkQnBUsCUL5IFycGSwNQvkgXJwdLBFBJvkgXK08GUL5IF0sBTwQMRIv/OAdPBRJEi/84CE8EEkSL/zgAMQASRLExADIKsgAishKyFEmyEYEEshCB0A+yAbNMIggWTwJMv4mKAgGL/hYrTFC+TBdMRIv/THAAQQAPiwBBAAoigAEAI08CVEyJI0L/84oBCIv/FicESwFQvkQnCEsCUL5ITCcJSwNQvkhMJwpLBFC+SBcnBUsFUL5IFycGSwZQvkgXJwdLB1C+SBcrTwhQvkgXTwVOB4mKAQGL/xWBIBJEKov/UL5EiSMpZUSJigEBKov/UL5FAYABACNPAlSJ", "clear": "CoEBQw=="}, "compilerInfo": {"compiler": "puya", "compilerVersion": {"major": 4, "minor": 7, "patch": 0}}, "desc": "Main contract for decentralized campus ticketing", "events": [], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBzbWFydF9jb250cmFjdHMudGlja2V0aW5nLmNvbnRyYWN0LlRpY2tldGluZ1BsYXRmb3JtLl9fYWxnb3B5X2VudHJ5cG9pbnRfd2l0aF9pbml0KCkgLT4gdWludDY0OgptYWluOgogICAgaW50Y2Jsb2NrIDEgMAogICAgYnl0ZWNibG9jayAweDE1MWY3Yzc1ICJldmVudF9jb3VudGVyIiAweDYzIDB4NjU2MSAweDY1NjMgMHg2NTcwIDB4NjU3NCAweDY1NzMgMHg2NTZlIDB4NjU3NiAweDY1NjQKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBibnogbWFpbl9hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6NDAtNDEKICAgIC8vICMgQ291bnRlciBmb3IgZ2VuZXJhdGluZyB1bmlxdWUgZXZlbnQgSURzCiAgICAvLyBzZWxmLmV2ZW50X2NvdW50ZXIgPSBVSW50NjQoMCkKICAgIGJ5dGVjXzEgLy8gImV2ZW50X2NvdW50ZXIiCiAgICBpbnRjXzEgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKCm1haW5fYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToyMgogICAgLy8gY2xhc3MgVGlja2V0aW5nUGxhdGZvcm0oQVJDNENvbnRyYWN0KToKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBtYWluX2JhcmVfcm91dGluZ0AxMwogICAgcHVzaGJ5dGVzcyAweGJjNTdhOTc3IDB4YzBmZjQwNTAgMHg4ZTJhYTgzZSAweDhkMTcyMjFjIDB4ODdhNjBjZjIgMHgyMmRjMDdlNSAweGRlOTEyMWZmIDB4YmM4MDIwOTMgLy8gbWV0aG9kICJyZWdpc3Rlcl9jbHViKHN0cmluZyxzdHJpbmcpc3RyaW5nIiwgbWV0aG9kICJjcmVhdGVfZXZlbnQoc3RyaW5nLHN0cmluZyx1aW50NjQsdWludDY0LHVpbnQ2NCl1aW50NjQiLCBtZXRob2QgImJ1eV90aWNrZXQodWludDY0LHBheSl1aW50NjQiLCBtZXRob2QgInZlcmlmeV90aWNrZXQodWludDY0LGFjY291bnQpYm9vbCIsIG1ldGhvZCAiZ2V0X2V2ZW50X2RldGFpbHModWludDY0KShieXRlW10sYnl0ZVtdLGJ5dGVbXSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSIsIG1ldGhvZCAiZ2V0X2NsdWJfbmFtZShieXRlW10pYnl0ZVtdIiwgbWV0aG9kICJnZXRfdG90YWxfZXZlbnRzKCl1aW50NjQiLCBtZXRob2QgImlzX2NsdWJfcmVnaXN0ZXJlZChhY2NvdW50KWJvb2wiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX3JlZ2lzdGVyX2NsdWJfcm91dGVANSBtYWluX2NyZWF0ZV9ldmVudF9yb3V0ZUA2IG1haW5fYnV5X3RpY2tldF9yb3V0ZUA3IG1haW5fdmVyaWZ5X3RpY2tldF9yb3V0ZUA4IG1haW5fZ2V0X2V2ZW50X2RldGFpbHNfcm91dGVAOSBtYWluX2dldF9jbHViX25hbWVfcm91dGVAMTAgbWFpbl9nZXRfdG90YWxfZXZlbnRzX3JvdXRlQDExIG1haW5faXNfY2x1Yl9yZWdpc3RlcmVkX3JvdXRlQDEyCgptYWluX2FmdGVyX2lmX2Vsc2VAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjIyCiAgICAvLyBjbGFzcyBUaWNrZXRpbmdQbGF0Zm9ybShBUkM0Q29udHJhY3QpOgogICAgaW50Y18xIC8vIDAKICAgIHJldHVybgoKbWFpbl9pc19jbHViX3JlZ2lzdGVyZWRfcm91dGVAMTI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjI1OQogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjIyCiAgICAvLyBjbGFzcyBUaWNrZXRpbmdQbGF0Zm9ybShBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYXMgQWNjb3VudHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MjU5CiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBjYWxsc3ViIGlzX2NsdWJfcmVnaXN0ZXJlZAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKbWFpbl9nZXRfdG90YWxfZXZlbnRzX3JvdXRlQDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToyNDkKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBnZXRfdG90YWxfZXZlbnRzCiAgICBpdG9iCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgptYWluX2dldF9jbHViX25hbWVfcm91dGVAMTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjIzMgogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjIyCiAgICAvLyBjbGFzcyBUaWNrZXRpbmdQbGF0Zm9ybShBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MjMyCiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICBjYWxsc3ViIGdldF9jbHViX25hbWUKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgptYWluX2dldF9ldmVudF9kZXRhaWxzX3JvdXRlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjIwNQogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjIyCiAgICAvLyBjbGFzcyBUaWNrZXRpbmdQbGF0Zm9ybShBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToyMDUKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGNhbGxzdWIgZ2V0X2V2ZW50X2RldGFpbHMKICAgIGRpZyA3CiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICB1bmNvdmVyIDgKICAgIGNvbmNhdAogICAgZGlnIDcKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHVuY292ZXIgOAogICAgY29uY2F0CiAgICBkaWcgNwogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgdW5jb3ZlciA4CiAgICBjb25jYXQKICAgIHVuY292ZXIgNwogICAgaXRvYgogICAgdW5jb3ZlciA3CiAgICBpdG9iCiAgICB1bmNvdmVyIDcKICAgIGl0b2IKICAgIHVuY292ZXIgNwogICAgaXRvYgogICAgdW5jb3ZlciA3CiAgICBpdG9iCiAgICBkaWcgNwogICAgbGVuCiAgICBwdXNoaW50IDQ2IC8vIDQ2CiAgICArCiAgICBkdXAKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBwdXNoYnl0ZXMgMHgwMDJlCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGRpZyA4CiAgICBsZW4KICAgIHVuY292ZXIgMgogICAgKwogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIGNvbmNhdAogICAgdW5jb3ZlciA1CiAgICBjb25jYXQKICAgIHVuY292ZXIgNAogICAgY29uY2F0CiAgICB1bmNvdmVyIDMKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCm1haW5fdmVyaWZ5X3RpY2tldF9yb3V0ZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxNzkKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToyMgogICAgLy8gY2xhc3MgVGlja2V0aW5nUGxhdGZvcm0oQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIHR4bmFzIEFjY291bnRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjE3OQogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgY2FsbHN1YiB2ZXJpZnlfdGlja2V0CiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgptYWluX2J1eV90aWNrZXRfcm91dGVANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MTI5CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToyMgogICAgLy8gY2xhc3MgVGlja2V0aW5nUGxhdGZvcm0oQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzAgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18wIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxMjkKICAgIC8vIEBhYmltZXRob2QoKQogICAgY2FsbHN1YiBidXlfdGlja2V0CiAgICBpdG9iCiAgICBieXRlY18wIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgptYWluX2NyZWF0ZV9ldmVudF9yb3V0ZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weTo2NAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MjIKICAgIC8vIGNsYXNzIFRpY2tldGluZ1BsYXRmb3JtKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6NjQKICAgIC8vIEBhYmltZXRob2QoKQogICAgY2FsbHN1YiBjcmVhdGVfZXZlbnQKICAgIGl0b2IKICAgIGJ5dGVjXzAgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCm1haW5fcmVnaXN0ZXJfY2x1Yl9yb3V0ZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weTo0MwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MjIKICAgIC8vIGNsYXNzIFRpY2tldGluZ1BsYXRmb3JtKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6NDMKICAgIC8vIEBhYmltZXRob2QoKQogICAgY2FsbHN1YiByZWdpc3Rlcl9jbHViCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKbWFpbl9iYXJlX3JvdXRpbmdAMTM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjIyCiAgICAvLyBjbGFzcyBUaWNrZXRpbmdQbGF0Zm9ybShBUkM0Q29udHJhY3QpOgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgYm56IG1haW5fYWZ0ZXJfaWZfZWxzZUAxNQogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gY3JlYXRpbmcKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMudGlja2V0aW5nLmNvbnRyYWN0LlRpY2tldGluZ1BsYXRmb3JtLnJlZ2lzdGVyX2NsdWIoY2x1Yl9uYW1lOiBieXRlcywgY29udGFjdDogYnl0ZXMpIC0+IGJ5dGVzOgpyZWdpc3Rlcl9jbHViOgogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weTo0My00NAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgcmVnaXN0ZXJfY2x1YihzZWxmLCBjbHViX25hbWU6IFN0cmluZywgY29udGFjdDogU3RyaW5nKSAtPiBTdHJpbmc6CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6NTUtNTYKICAgIC8vICMgQ2hlY2sgaWYgY2x1YiBhbHJlYWR5IHJlZ2lzdGVyZWQKICAgIC8vIGV4aXN0aW5nX25hbWUsIGV4aXN0cyA9IHNlbGYuY2x1Yl9uYW1lcy5tYXliZShUeG4uc2VuZGVyKQogICAgYnl0ZWNfMiAvLyAweDYzCiAgICB0eG4gU2VuZGVyCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weTo1NwogICAgLy8gYXNzZXJ0IG5vdCBleGlzdHMsICJDbHViIGFscmVhZHkgcmVnaXN0ZXJlZCIKICAgICEKICAgIGFzc2VydCAvLyBDbHViIGFscmVhZHkgcmVnaXN0ZXJlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weTo1OS02MAogICAgLy8gIyBTdG9yZSBjbHViIG5hbWUgKGNvbnRhY3QgaW5mbyBjYW4gYmUgc3RvcmVkIG9mZi1jaGFpbiBvciBpbiBhIHNlcGFyYXRlIGJveCBpZiBuZWVkZWQpCiAgICAvLyBzZWxmLmNsdWJfbmFtZXNbVHhuLnNlbmRlcl0gPSBjbHViX25hbWUuYnl0ZXMKICAgIGJ5dGVjXzIgLy8gMHg2MwogICAgdHhuIFNlbmRlcgogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9kZWwKICAgIHBvcAogICAgZnJhbWVfZGlnIC0yCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjYyCiAgICAvLyByZXR1cm4gU3RyaW5nKCJDbHViIHJlZ2lzdGVyZWQgc3VjY2Vzc2Z1bGx5IikKICAgIHB1c2hieXRlcyAiQ2x1YiByZWdpc3RlcmVkIHN1Y2Nlc3NmdWxseSIKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy50aWNrZXRpbmcuY29udHJhY3QuVGlja2V0aW5nUGxhdGZvcm0uY3JlYXRlX2V2ZW50KGV2ZW50X25hbWU6IGJ5dGVzLCB2ZW51ZTogYnl0ZXMsIGV2ZW50X2RhdGU6IHVpbnQ2NCwgdGlja2V0X3ByaWNlOiB1aW50NjQsIHRpY2tldF9jb3VudDogdWludDY0KSAtPiB1aW50NjQ6CmNyZWF0ZV9ldmVudDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6NjQtNzIKICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gZGVmIGNyZWF0ZV9ldmVudCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGV2ZW50X25hbWU6IFN0cmluZywKICAgIC8vICAgICB2ZW51ZTogU3RyaW5nLAogICAgLy8gICAgIGV2ZW50X2RhdGU6IFVJbnQ2NCwKICAgIC8vICAgICB0aWNrZXRfcHJpY2U6IFVJbnQ2NCwKICAgIC8vICAgICB0aWNrZXRfY291bnQ6IFVJbnQ2NCwKICAgIC8vICkgLT4gVUludDY0OgogICAgcHJvdG8gNSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5Ojg2LTg3CiAgICAvLyAjIFZlcmlmeSBjYWxsZXIgaXMgYSByZWdpc3RlcmVkIGNsdWIKICAgIC8vIGNsdWJfbmFtZV92YWwsIGNsdWJfZXhpc3RzID0gc2VsZi5jbHViX25hbWVzLm1heWJlKFR4bi5zZW5kZXIpCiAgICBieXRlY18yIC8vIDB4NjMKICAgIHR4biBTZW5kZXIKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5Ojg4CiAgICAvLyBhc3NlcnQgY2x1Yl9leGlzdHMsICJPbmx5IHJlZ2lzdGVyZWQgY2x1YnMgY2FuIGNyZWF0ZSBldmVudHMiCiAgICBhc3NlcnQgLy8gT25seSByZWdpc3RlcmVkIGNsdWJzIGNhbiBjcmVhdGUgZXZlbnRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjkwLTkxCiAgICAvLyAjIFZhbGlkYXRlIGlucHV0cwogICAgLy8gYXNzZXJ0IGV2ZW50X2RhdGUgPiBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCwgIkV2ZW50IG11c3QgYmUgaW4gZnV0dXJlIgogICAgZnJhbWVfZGlnIC0zCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICA+CiAgICBhc3NlcnQgLy8gRXZlbnQgbXVzdCBiZSBpbiBmdXR1cmUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6OTIKICAgIC8vIGFzc2VydCB0aWNrZXRfcHJpY2UgPiAwLCAiVGlja2V0IHByaWNlIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAiCiAgICBmcmFtZV9kaWcgLTIKICAgIGFzc2VydCAvLyBUaWNrZXQgcHJpY2UgbXVzdCBiZSBncmVhdGVyIHRoYW4gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weTo5MwogICAgLy8gYXNzZXJ0IHRpY2tldF9jb3VudCA+IDAsICJNdXN0IGhhdmUgYXQgbGVhc3QgMSB0aWNrZXQiCiAgICBmcmFtZV9kaWcgLTEKICAgIGFzc2VydCAvLyBNdXN0IGhhdmUgYXQgbGVhc3QgMSB0aWNrZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6OTQKICAgIC8vIGFzc2VydCB0aWNrZXRfY291bnQgPD0gMTAwMDAsICJDYW5ub3QgY3JlYXRlIG1vcmUgdGhhbiAxMDAwMCB0aWNrZXRzIgogICAgZnJhbWVfZGlnIC0xCiAgICBwdXNoaW50IDEwMDAwIC8vIDEwMDAwCiAgICA8PQogICAgYXNzZXJ0IC8vIENhbm5vdCBjcmVhdGUgbW9yZSB0aGFuIDEwMDAwIHRpY2tldHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6OTYtOTcKICAgIC8vICMgR2VuZXJhdGUgdW5pcXVlIGV2ZW50IElECiAgICAvLyBzZWxmLmV2ZW50X2NvdW50ZXIgKz0gVUludDY0KDEpCiAgICBpbnRjXzEgLy8gMAogICAgYnl0ZWNfMSAvLyAiZXZlbnRfY291bnRlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5ldmVudF9jb3VudGVyIGV4aXN0cwogICAgaW50Y18wIC8vIDEKICAgICsKICAgIGJ5dGVjXzEgLy8gImV2ZW50X2NvdW50ZXIiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weTo5OAogICAgLy8gZXZlbnRfaWQgPSBzZWxmLmV2ZW50X2NvdW50ZXIKICAgIGludGNfMSAvLyAwCiAgICBieXRlY18xIC8vICJldmVudF9jb3VudGVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmV2ZW50X2NvdW50ZXIgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjEwMC0xMTMKICAgIC8vICMgQ3JlYXRlIHRpY2tldCBBU0EgKEFsZ29yYW5kIFN0YW5kYXJkIEFzc2V0KQogICAgLy8gdGlja2V0X2FzYSA9IGl0eG4uQXNzZXRDb25maWcoCiAgICAvLyAgICAgdG90YWw9dGlja2V0X2NvdW50LAogICAgLy8gICAgIGRlY2ltYWxzPTAsICAjIFRpY2tldHMgYXJlIG5vbi1kaXZpc2libGUKICAgIC8vICAgICBkZWZhdWx0X2Zyb3plbj1GYWxzZSwKICAgIC8vICAgICB1bml0X25hbWU9U3RyaW5nKCJUS1QiKSwKICAgIC8vICAgICBhc3NldF9uYW1lPWV2ZW50X25hbWUsCiAgICAvLyAgICAgdXJsPVN0cmluZygiaHR0cHM6Ly9jYW1wdXMtdGl4LmFsZ28iKSwKICAgIC8vICAgICBtYW5hZ2VyPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgcmVzZXJ2ZT1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIGZyZWV6ZT1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIGNsYXdiYWNrPUdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsCiAgICAvLyAgICAgZmVlPVVJbnQ2NCgxNTAwMCksICAjIEluY3JlYXNlZCBmZWUgZm9yIGlubmVyIEFTQSBjcmVhdGlvbiB0cmFuc2FjdGlvbgogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxMDgKICAgIC8vIG1hbmFnZXI9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjEwOS0xMTEKICAgIC8vIHJlc2VydmU9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vIGZyZWV6ZT1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gY2xhd2JhY2s9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIGR1cG4gMwogICAgaXR4bl9maWVsZCBDb25maWdBc3NldENsYXdiYWNrCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RnJlZXplCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0UmVzZXJ2ZQogICAgaXR4bl9maWVsZCBDb25maWdBc3NldE1hbmFnZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MTA3CiAgICAvLyB1cmw9U3RyaW5nKCJodHRwczovL2NhbXB1cy10aXguYWxnbyIpLAogICAgcHVzaGJ5dGVzICJodHRwczovL2NhbXB1cy10aXguYWxnbyIKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRVUkwKICAgIGZyYW1lX2RpZyAtNQogICAgaXR4bl9maWVsZCBDb25maWdBc3NldE5hbWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MTA1CiAgICAvLyB1bml0X25hbWU9U3RyaW5nKCJUS1QiKSwKICAgIHB1c2hieXRlcyAiVEtUIgogICAgaXR4bl9maWVsZCBDb25maWdBc3NldFVuaXROYW1lCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjEwNAogICAgLy8gZGVmYXVsdF9mcm96ZW49RmFsc2UsCiAgICBpbnRjXzEgLy8gMAogICAgaXR4bl9maWVsZCBDb25maWdBc3NldERlZmF1bHRGcm96ZW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MTAzCiAgICAvLyBkZWNpbWFscz0wLCAgIyBUaWNrZXRzIGFyZSBub24tZGl2aXNpYmxlCiAgICBpbnRjXzEgLy8gMAogICAgaXR4bl9maWVsZCBDb25maWdBc3NldERlY2ltYWxzCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRUb3RhbAogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxMDAtMTAxCiAgICAvLyAjIENyZWF0ZSB0aWNrZXQgQVNBIChBbGdvcmFuZCBTdGFuZGFyZCBBc3NldCkKICAgIC8vIHRpY2tldF9hc2EgPSBpdHhuLkFzc2V0Q29uZmlnKAogICAgcHVzaGludCAzIC8vIGFjZmcKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MTEyCiAgICAvLyBmZWU9VUludDY0KDE1MDAwKSwgICMgSW5jcmVhc2VkIGZlZSBmb3IgaW5uZXIgQVNBIGNyZWF0aW9uIHRyYW5zYWN0aW9uCiAgICBwdXNoaW50IDE1MDAwIC8vIDE1MDAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxMDAtMTEzCiAgICAvLyAjIENyZWF0ZSB0aWNrZXQgQVNBIChBbGdvcmFuZCBTdGFuZGFyZCBBc3NldCkKICAgIC8vIHRpY2tldF9hc2EgPSBpdHhuLkFzc2V0Q29uZmlnKAogICAgLy8gICAgIHRvdGFsPXRpY2tldF9jb3VudCwKICAgIC8vICAgICBkZWNpbWFscz0wLCAgIyBUaWNrZXRzIGFyZSBub24tZGl2aXNpYmxlCiAgICAvLyAgICAgZGVmYXVsdF9mcm96ZW49RmFsc2UsCiAgICAvLyAgICAgdW5pdF9uYW1lPVN0cmluZygiVEtUIiksCiAgICAvLyAgICAgYXNzZXRfbmFtZT1ldmVudF9uYW1lLAogICAgLy8gICAgIHVybD1TdHJpbmcoImh0dHBzOi8vY2FtcHVzLXRpeC5hbGdvIiksCiAgICAvLyAgICAgbWFuYWdlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIHJlc2VydmU9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICBmcmVlemU9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICBjbGF3YmFjaz1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIGZlZT1VSW50NjQoMTUwMDApLCAgIyBJbmNyZWFzZWQgZmVlIGZvciBpbm5lciBBU0EgY3JlYXRpb24gdHJhbnNhY3Rpb24KICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIENyZWF0ZWRBc3NldElECiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjExNy0xMTgKICAgIC8vICMgU3RvcmUgZXZlbnQgaW5mb3JtYXRpb24gaW4gc2VwYXJhdGUgYm94ZXMKICAgIC8vIHNlbGYuZXZlbnRfY2x1YnNbZXZlbnRfaWRdID0gVHhuLnNlbmRlcgogICAgZGlnIDEKICAgIGl0b2IKICAgIGJ5dGVjIDQgLy8gMHg2NTYzCiAgICBkaWcgMQogICAgY29uY2F0CiAgICB0eG4gU2VuZGVyCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjExOQogICAgLy8gc2VsZi5ldmVudF9uYW1lc1tldmVudF9pZF0gPSBldmVudF9uYW1lLmJ5dGVzCiAgICBieXRlYyA4IC8vIDB4NjU2ZQogICAgZGlnIDEKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGZyYW1lX2RpZyAtNQogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxMjAKICAgIC8vIHNlbGYuZXZlbnRfdmVudWVzW2V2ZW50X2lkXSA9IHZlbnVlLmJ5dGVzCiAgICBieXRlYyA5IC8vIDB4NjU3NgogICAgZGlnIDEKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGZyYW1lX2RpZyAtNAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxMjEKICAgIC8vIHNlbGYuZXZlbnRfZGF0ZXNbZXZlbnRfaWRdID0gZXZlbnRfZGF0ZQogICAgYnl0ZWMgMTAgLy8gMHg2NTY0CiAgICBkaWcgMQogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTMKICAgIGl0b2IKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MTIyCiAgICAvLyBzZWxmLmV2ZW50X3ByaWNlc1tldmVudF9pZF0gPSB0aWNrZXRfcHJpY2UKICAgIGJ5dGVjIDUgLy8gMHg2NTcwCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTIKICAgIGl0b2IKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MTIzCiAgICAvLyBzZWxmLmV2ZW50X3RvdGFsW2V2ZW50X2lkXSA9IHRpY2tldF9jb3VudAogICAgYnl0ZWMgNiAvLyAweDY1NzQKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxMjQKICAgIC8vIHNlbGYuZXZlbnRfc29sZFtldmVudF9pZF0gPSBVSW50NjQoMCkKICAgIGJ5dGVjIDcgLy8gMHg2NTczCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBpbnRjXzEgLy8gMAogICAgaXRvYgogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxMjUKICAgIC8vIHNlbGYuZXZlbnRfYXNzZXRzW2V2ZW50X2lkXSA9IHRpY2tldF9hc3NldF9pZAogICAgYnl0ZWNfMyAvLyAweDY1NjEKICAgIHN3YXAKICAgIGNvbmNhdAogICAgc3dhcAogICAgaXRvYgogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxMjcKICAgIC8vIHJldHVybiBldmVudF9pZAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnRpY2tldGluZy5jb250cmFjdC5UaWNrZXRpbmdQbGF0Zm9ybS5idXlfdGlja2V0KGV2ZW50X2lkOiB1aW50NjQsIHBheW1lbnQ6IHVpbnQ2NCkgLT4gdWludDY0OgpidXlfdGlja2V0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxMjktMTM0CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBidXlfdGlja2V0KAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZXZlbnRfaWQ6IFVJbnQ2NCwKICAgIC8vICAgICBwYXltZW50OiBndHhuLlBheW1lbnRUcmFuc2FjdGlvbiwKICAgIC8vICkgLT4gVUludDY0OgogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjE0Ni0xNDcKICAgIC8vICMgVmVyaWZ5IGV2ZW50IGV4aXN0cwogICAgLy8gY2x1Yl9vd25lciwgZXhpc3RzID0gc2VsZi5ldmVudF9jbHVicy5tYXliZShldmVudF9pZCkKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgYnl0ZWMgNCAvLyAweDY1NjMKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MTQ4CiAgICAvLyBhc3NlcnQgZXhpc3RzLCAiRXZlbnQgbm90IGZvdW5kIgogICAgYXNzZXJ0IC8vIEV2ZW50IG5vdCBmb3VuZAogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxNTAtMTUxCiAgICAvLyAjIEdldCBldmVudCBkZXRhaWxzCiAgICAvLyB0aWNrZXRfcHJpY2UsIHByaWNlX2V4aXN0cyA9IHNlbGYuZXZlbnRfcHJpY2VzLm1heWJlKGV2ZW50X2lkKQogICAgYnl0ZWMgNSAvLyAweDY1NzAKICAgIGRpZyAyCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIHBvcAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxNTIKICAgIC8vIHRvdGFsX3RpY2tldHMsIHRvdGFsX2V4aXN0cyA9IHNlbGYuZXZlbnRfdG90YWwubWF5YmUoZXZlbnRfaWQpCiAgICBieXRlYyA2IC8vIDB4NjU3NAogICAgZGlnIDMKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgcG9wCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjE1MwogICAgLy8gc29sZF90aWNrZXRzLCBzb2xkX2V4aXN0cyA9IHNlbGYuZXZlbnRfc29sZC5tYXliZShldmVudF9pZCkKICAgIGJ5dGVjIDcgLy8gMHg2NTczCiAgICBkaWcgNAogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9nZXQKICAgIHBvcAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxNTQKICAgIC8vIHRpY2tldF9hc3NldF9pZCwgYXNzZXRfZXhpc3RzID0gc2VsZi5ldmVudF9hc3NldHMubWF5YmUoZXZlbnRfaWQpCiAgICBieXRlY18zIC8vIDB4NjU2MQogICAgdW5jb3ZlciA2CiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIHBvcAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxNTYtMTU3CiAgICAvLyAjIENoZWNrIHRpY2tldHMgYXZhaWxhYmxlCiAgICAvLyBhc3NlcnQgc29sZF90aWNrZXRzIDwgdG90YWxfdGlja2V0cywgIkV2ZW50IHNvbGQgb3V0IgogICAgZGlnIDEKICAgIHVuY292ZXIgNAogICAgPAogICAgYXNzZXJ0IC8vIEV2ZW50IHNvbGQgb3V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjE1OS0xNjAKICAgIC8vICMgVmVyaWZ5IHBheW1lbnQgdHJhbnNhY3Rpb24KICAgIC8vIGFzc2VydCBwYXltZW50LnJlY2VpdmVyID09IGNsdWJfb3duZXIsICJQYXltZW50IG11c3QgZ28gdG8gY2x1YiIKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIHVuY292ZXIgNQogICAgPT0KICAgIGFzc2VydCAvLyBQYXltZW50IG11c3QgZ28gdG8gY2x1YgogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxNjEKICAgIC8vIGFzc2VydCBwYXltZW50LmFtb3VudCA9PSB0aWNrZXRfcHJpY2UsICJJbmNvcnJlY3QgcGF5bWVudCBhbW91bnQiCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgdW5jb3ZlciA0CiAgICA9PQogICAgYXNzZXJ0IC8vIEluY29ycmVjdCBwYXltZW50IGFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxNjIKICAgIC8vIGFzc2VydCBwYXltZW50LnNlbmRlciA9PSBUeG4uc2VuZGVyLCAiUGF5bWVudCBzZW5kZXIgbWlzbWF0Y2giCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgPT0KICAgIGFzc2VydCAvLyBQYXltZW50IHNlbmRlciBtaXNtYXRjaAogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxNjQtMTcyCiAgICAvLyAjIFRyYW5zZmVyIHRpY2tldCBBU0EgdG8gYnV5ZXIKICAgIC8vICMgTm90ZTogQnV5ZXIgbXVzdCBoYXZlIG9wdGVkLWluIHRvIHRoZSBBU0EgZmlyc3QKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PXRpY2tldF9hc3NldF9pZCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1UeG4uc2VuZGVyLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD0xLAogICAgLy8gICAgIHNlbmRlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIGZlZT1VSW50NjQoMjAwMCksCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjE2OAogICAgLy8gYXNzZXRfcmVjZWl2ZXI9VHhuLnNlbmRlciwKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MTcwCiAgICAvLyBzZW5kZXI9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxNjkKICAgIC8vIGFzc2V0X2Ftb3VudD0xLAogICAgaW50Y18wIC8vIDEKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxNjQtMTY2CiAgICAvLyAjIFRyYW5zZmVyIHRpY2tldCBBU0EgdG8gYnV5ZXIKICAgIC8vICMgTm90ZTogQnV5ZXIgbXVzdCBoYXZlIG9wdGVkLWluIHRvIHRoZSBBU0EgZmlyc3QKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIHB1c2hpbnQgNCAvLyBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxNzEKICAgIC8vIGZlZT1VSW50NjQoMjAwMCksCiAgICBwdXNoaW50IDIwMDAgLy8gMjAwMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MTY0LTE3MgogICAgLy8gIyBUcmFuc2ZlciB0aWNrZXQgQVNBIHRvIGJ1eWVyCiAgICAvLyAjIE5vdGU6IEJ1eWVyIG11c3QgaGF2ZSBvcHRlZC1pbiB0byB0aGUgQVNBIGZpcnN0CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD10aWNrZXRfYXNzZXRfaWQsCiAgICAvLyAgICAgYXNzZXRfcmVjZWl2ZXI9VHhuLnNlbmRlciwKICAgIC8vICAgICBhc3NldF9hbW91bnQ9MSwKICAgIC8vICAgICBzZW5kZXI9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICBmZWU9VUludDY0KDIwMDApLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MTc0LTE3NQogICAgLy8gIyBVcGRhdGUgc29sZCB0aWNrZXRzIGNvdW50ZXIKICAgIC8vIHNlbGYuZXZlbnRfc29sZFtldmVudF9pZF0gPSBzb2xkX3RpY2tldHMgKyBVSW50NjQoMSkKICAgIHN3YXAKICAgIGludGNfMCAvLyAxCiAgICArCiAgICBpdG9iCiAgICB1bmNvdmVyIDIKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MTc3CiAgICAvLyByZXR1cm4gdGlja2V0X2Fzc2V0X2lkCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudGlja2V0aW5nLmNvbnRyYWN0LlRpY2tldGluZ1BsYXRmb3JtLnZlcmlmeV90aWNrZXQoZXZlbnRfaWQ6IHVpbnQ2NCwgYXR0ZW5kZWU6IGJ5dGVzKSAtPiBieXRlczoKdmVyaWZ5X3RpY2tldDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MTc5LTE4NAogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgLy8gZGVmIHZlcmlmeV90aWNrZXQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBldmVudF9pZDogVUludDY0LAogICAgLy8gICAgIGF0dGVuZGVlOiBBY2NvdW50LAogICAgLy8gKSAtPiBCb29sOgogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjE5NS0xOTYKICAgIC8vICMgR2V0IGV2ZW50IHRpY2tldCBhc3NldCBJRAogICAgLy8gdGlja2V0X2Fzc2V0X2lkLCBleGlzdHMgPSBzZWxmLmV2ZW50X2Fzc2V0cy5tYXliZShldmVudF9pZCkKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgYnl0ZWNfMyAvLyAweDY1NjEKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgc3dhcAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToxOTcKICAgIC8vIGFzc2VydCBleGlzdHMsICJFdmVudCBub3QgZm91bmQiCiAgICBzd2FwCiAgICBhc3NlcnQgLy8gRXZlbnQgbm90IGZvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjE5OS0yMDAKICAgIC8vICMgQ2hlY2sgaWYgYXR0ZW5kZWUgaGFzIGJhbGFuY2Ugb2YgdGlja2V0IEFTQQogICAgLy8gYXNzZXRfYmFsYW5jZSwgYmFsYW5jZV9leGlzdHMgPSBvcC5Bc3NldEhvbGRpbmdHZXQuYXNzZXRfYmFsYW5jZShhdHRlbmRlZSwgdGlja2V0X2Fzc2V0X2lkKQogICAgZnJhbWVfZGlnIC0xCiAgICBzd2FwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MjAyLTIwMwogICAgLy8gIyBSZXR1cm4gVHJ1ZSBpZiB0aGUgYWNjb3VudCBoYXMgb3B0ZWQgaW4gYW5kIGhhcyBhdCBsZWFzdCAxIHRpY2tldAogICAgLy8gcmV0dXJuIEJvb2woYmFsYW5jZV9leGlzdHMgYW5kIGFzc2V0X2JhbGFuY2UgPiAwKQogICAgYnogdmVyaWZ5X3RpY2tldF9ib29sX2ZhbHNlQDMKICAgIGZyYW1lX2RpZyAwCiAgICBieiB2ZXJpZnlfdGlja2V0X2Jvb2xfZmFsc2VAMwogICAgaW50Y18wIC8vIDEKCnZlcmlmeV90aWNrZXRfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToyMDItMjAzCiAgICAvLyAjIFJldHVybiBUcnVlIGlmIHRoZSBhY2NvdW50IGhhcyBvcHRlZCBpbiBhbmQgaGFzIGF0IGxlYXN0IDEgdGlja2V0CiAgICAvLyByZXR1cm4gQm9vbChiYWxhbmNlX2V4aXN0cyBhbmQgYXNzZXRfYmFsYW5jZSA+IDApCiAgICBwdXNoYnl0ZXMgMHgwMAogICAgaW50Y18xIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBzd2FwCiAgICByZXRzdWIKCnZlcmlmeV90aWNrZXRfYm9vbF9mYWxzZUAzOgogICAgaW50Y18xIC8vIDAKICAgIGIgdmVyaWZ5X3RpY2tldF9ib29sX21lcmdlQDQKCgovLyBzbWFydF9jb250cmFjdHMudGlja2V0aW5nLmNvbnRyYWN0LlRpY2tldGluZ1BsYXRmb3JtLmdldF9ldmVudF9kZXRhaWxzKGV2ZW50X2lkOiB1aW50NjQpIC0+IGJ5dGVzLCBieXRlcywgYnl0ZXMsIHVpbnQ2NCwgdWludDY0LCB1aW50NjQsIHVpbnQ2NCwgdWludDY0OgpnZXRfZXZlbnRfZGV0YWlsczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MjA1LTIwOQogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgLy8gZGVmIGdldF9ldmVudF9kZXRhaWxzKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZXZlbnRfaWQ6IFVJbnQ2NCwKICAgIC8vICkgLT4gdHVwbGVbQnl0ZXMsIEJ5dGVzLCBCeXRlcywgVUludDY0LCBVSW50NjQsIFVJbnQ2NCwgVUludDY0LCBVSW50NjRdOgogICAgcHJvdG8gMSA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjIxOQogICAgLy8gY2x1Yl9vd25lciwgZXhpc3RzID0gc2VsZi5ldmVudF9jbHVicy5tYXliZShldmVudF9pZCkKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgYnl0ZWMgNCAvLyAweDY1NjMKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MjIwCiAgICAvLyBhc3NlcnQgZXhpc3RzLCAiRXZlbnQgbm90IGZvdW5kIgogICAgYXNzZXJ0IC8vIEV2ZW50IG5vdCBmb3VuZAogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToyMjIKICAgIC8vIGV2ZW50X25hbWUsIG5hbWVfZXhpc3RzID0gc2VsZi5ldmVudF9uYW1lcy5tYXliZShldmVudF9pZCkKICAgIGJ5dGVjIDggLy8gMHg2NTZlCiAgICBkaWcgMgogICAgY29uY2F0CiAgICBib3hfZ2V0CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MjIzCiAgICAvLyB2ZW51ZSwgdmVudWVfZXhpc3RzID0gc2VsZi5ldmVudF92ZW51ZXMubWF5YmUoZXZlbnRfaWQpCiAgICBieXRlYyA5IC8vIDB4NjU3NgogICAgZGlnIDMKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjIyNAogICAgLy8gZGF0ZSwgZGF0ZV9leGlzdHMgPSBzZWxmLmV2ZW50X2RhdGVzLm1heWJlKGV2ZW50X2lkKQogICAgYnl0ZWMgMTAgLy8gMHg2NTY0CiAgICBkaWcgNAogICAgY29uY2F0CiAgICBib3hfZ2V0CiAgICBwb3AKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MjI1CiAgICAvLyBwcmljZSwgcHJpY2VfZXhpc3RzID0gc2VsZi5ldmVudF9wcmljZXMubWF5YmUoZXZlbnRfaWQpCiAgICBieXRlYyA1IC8vIDB4NjU3MAogICAgZGlnIDUKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgcG9wCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjIyNgogICAgLy8gdG90YWwsIHRvdGFsX2V4aXN0cyA9IHNlbGYuZXZlbnRfdG90YWwubWF5YmUoZXZlbnRfaWQpCiAgICBieXRlYyA2IC8vIDB4NjU3NAogICAgZGlnIDYKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgcG9wCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjIyNwogICAgLy8gc29sZCwgc29sZF9leGlzdHMgPSBzZWxmLmV2ZW50X3NvbGQubWF5YmUoZXZlbnRfaWQpCiAgICBieXRlYyA3IC8vIDB4NjU3MwogICAgZGlnIDcKICAgIGNvbmNhdAogICAgYm94X2dldAogICAgcG9wCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjIyOAogICAgLy8gYXNzZXRfaWQsIGFzc2V0X2V4aXN0cyA9IHNlbGYuZXZlbnRfYXNzZXRzLm1heWJlKGV2ZW50X2lkKQogICAgYnl0ZWNfMyAvLyAweDY1NjEKICAgIHVuY292ZXIgOAogICAgY29uY2F0CiAgICBib3hfZ2V0CiAgICBwb3AKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MjMwCiAgICAvLyByZXR1cm4gY2x1Yl9vd25lci5ieXRlcywgZXZlbnRfbmFtZSwgdmVudWUsIGRhdGUsIHByaWNlLCB0b3RhbCwgc29sZCwgYXNzZXRfaWQKICAgIHVuY292ZXIgNQogICAgY292ZXIgNwogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnRpY2tldGluZy5jb250cmFjdC5UaWNrZXRpbmdQbGF0Zm9ybS5nZXRfY2x1Yl9uYW1lKGNsdWJfYWRkcmVzczogYnl0ZXMpIC0+IGJ5dGVzOgpnZXRfY2x1Yl9uYW1lOgogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToyMzItMjMzCiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICAvLyBkZWYgZ2V0X2NsdWJfbmFtZShzZWxmLCBjbHViX2FkZHJlc3M6IEJ5dGVzKSAtPiBCeXRlczoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToyNDMtMjQ0CiAgICAvLyAjIENvbnZlcnQgQnl0ZXMgdG8gQWNjb3VudCBmb3IgQm94TWFwIGxvb2t1cAogICAgLy8gY2x1Yl9hY2NvdW50ID0gQWNjb3VudChjbHViX2FkZHJlc3MpCiAgICBmcmFtZV9kaWcgLTEKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBBZGRyZXNzIGxlbmd0aCBpcyAzMiBieXRlcwogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToyNDUKICAgIC8vIGNsdWJfbmFtZSwgZXhpc3RzID0gc2VsZi5jbHViX25hbWVzLm1heWJlKGNsdWJfYWNjb3VudCkKICAgIGJ5dGVjXzIgLy8gMHg2MwogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIGJveF9nZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MjQ2CiAgICAvLyBhc3NlcnQgZXhpc3RzLCAiQ2x1YiBub3QgcmVnaXN0ZXJlZCIKICAgIGFzc2VydCAvLyBDbHViIG5vdCByZWdpc3RlcmVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvdGlja2V0aW5nL2NvbnRyYWN0LnB5OjI0NwogICAgLy8gcmV0dXJuIGNsdWJfbmFtZQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnRpY2tldGluZy5jb250cmFjdC5UaWNrZXRpbmdQbGF0Zm9ybS5nZXRfdG90YWxfZXZlbnRzKCkgLT4gdWludDY0OgpnZXRfdG90YWxfZXZlbnRzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToyNTcKICAgIC8vIHJldHVybiBzZWxmLmV2ZW50X2NvdW50ZXIKICAgIGludGNfMSAvLyAwCiAgICBieXRlY18xIC8vICJldmVudF9jb3VudGVyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmV2ZW50X2NvdW50ZXIgZXhpc3RzCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMudGlja2V0aW5nLmNvbnRyYWN0LlRpY2tldGluZ1BsYXRmb3JtLmlzX2NsdWJfcmVnaXN0ZXJlZChjbHViX2FkZHJlc3M6IGJ5dGVzKSAtPiBieXRlczoKaXNfY2x1Yl9yZWdpc3RlcmVkOgogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToyNTktMjYwCiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICAvLyBkZWYgaXNfY2x1Yl9yZWdpc3RlcmVkKHNlbGYsIGNsdWJfYWRkcmVzczogQWNjb3VudCkgLT4gQm9vbDoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3RpY2tldGluZy9jb250cmFjdC5weToyNzAKICAgIC8vIGNsdWJfbmFtZV92YWwsIGV4aXN0cyA9IHNlbGYuY2x1Yl9uYW1lcy5tYXliZShjbHViX2FkZHJlc3MpCiAgICBieXRlY18yIC8vIDB4NjMKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICBib3hfZ2V0CiAgICBidXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90aWNrZXRpbmcvY29udHJhY3QucHk6MjcxCiAgICAvLyByZXR1cm4gQm9vbChleGlzdHMpCiAgICBwdXNoYnl0ZXMgMHgwMAogICAgaW50Y18xIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICByZXRzdWIK", "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"}, "sourceInfo": {"approval": {"pcOffsetMethod": "none", "sourceInfo": [{"pc": [935], "errorMessage": "Address length is 32 bytes"}, {"pc": [541], "errorMessage": "Cannot create more than 10000 tickets"}, {"pc": [470], "errorMessage": "Club already registered"}, {"pc": [941], "errorMessage": "Club not registered"}, {"pc": [528], "errorMessage": "Event must be in future"}, {"pc": [715, 825, 865], "errorMessage": "Event not found"}, {"pc": [753], "errorMessage": "Event sold out"}, {"pc": [769], "errorMessage": "Incorrect payment amount"}, {"pc": [534], "errorMessage": "Must have at least 1 ticket"}, {"pc": [133, 155, 172, 202, 317, 343, 374, 415], "errorMessage": "OnCompletion is not NoOp"}, {"pc": [522], "errorMessage": "Only registered clubs can create events"}, {"pc": [761], "errorMessage": "Payment must go to club"}, {"pc": [777], "errorMessage": "Payment sender mismatch"}, {"pc": [531], "errorMessage": "Ticket price must be greater than 0"}, {"pc": [456], "errorMessage": "can only call when creating"}, {"pc": [136, 158, 175, 205, 320, 346, 377, 418], "errorMessage": "can only call when not creating"}, {"pc": [545, 554, 946], "errorMessage": "check self.event_counter exists"}, {"pc": [360], "errorMessage": "transaction type is pay"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True, kw_only=True)
class RegisterClubArgs:
    """Dataclass for register_club arguments"""
    club_name: str
    contact: str

    @property
    def abi_method_signature(self) -> str:
        return "register_club(string,string)string"

@dataclasses.dataclass(frozen=True, kw_only=True)
class CreateEventArgs:
    """Dataclass for create_event arguments"""
    event_name: str
    venue: str
    event_date: int
    ticket_price: int
    ticket_count: int

    @property
    def abi_method_signature(self) -> str:
        return "create_event(string,string,uint64,uint64,uint64)uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class BuyTicketArgs:
    """Dataclass for buy_ticket arguments"""
    event_id: int
    payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "buy_ticket(uint64,pay)uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class VerifyTicketArgs:
    """Dataclass for verify_ticket arguments"""
    event_id: int
    attendee: str | bytes

    @property
    def abi_method_signature(self) -> str:
        return "verify_ticket(uint64,account)bool"

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetEventDetailsArgs:
    """Dataclass for get_event_details arguments"""
    event_id: int

    @property
    def abi_method_signature(self) -> str:
        return "get_event_details(uint64)(byte[],byte[],byte[],uint64,uint64,uint64,uint64,uint64)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetClubNameArgs:
    """Dataclass for get_club_name arguments"""
    club_address: bytes | str

    @property
    def abi_method_signature(self) -> str:
        return "get_club_name(byte[])byte[]"

@dataclasses.dataclass(frozen=True, kw_only=True)
class IsClubRegisteredArgs:
    """Dataclass for is_club_registered arguments"""
    club_address: str | bytes

    @property
    def abi_method_signature(self) -> str:
        return "is_club_registered(account)bool"


class TicketingPlatformParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def register_club(
        self,
        args: tuple[str, str] | RegisterClubArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "register_club(string,string)string",
            "args": method_args,
        }))

    def create_event(
        self,
        args: tuple[str, str, int, int, int] | CreateEventArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_event(string,string,uint64,uint64,uint64)uint64",
            "args": method_args,
        }))

    def buy_ticket(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | BuyTicketArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "buy_ticket(uint64,pay)uint64",
            "args": method_args,
        }))

    def verify_ticket(
        self,
        args: tuple[int, str | bytes] | VerifyTicketArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "verify_ticket(uint64,account)bool",
            "args": method_args,
        }))

    def get_event_details(
        self,
        args: tuple[int] | GetEventDetailsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_event_details(uint64)(byte[],byte[],byte[],uint64,uint64,uint64,uint64,uint64)",
            "args": method_args,
        }))

    def get_club_name(
        self,
        args: tuple[bytes | str] | GetClubNameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_club_name(byte[])byte[]",
            "args": method_args,
        }))

    def get_total_events(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_total_events()uint64",
        }))

    def is_club_registered(
        self,
        args: tuple[str | bytes] | IsClubRegisteredArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "is_club_registered(account)bool",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class TicketingPlatformCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def register_club(
        self,
        args: tuple[str, str] | RegisterClubArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "register_club(string,string)string",
            "args": method_args,
        }))

    def create_event(
        self,
        args: tuple[str, str, int, int, int] | CreateEventArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_event(string,string,uint64,uint64,uint64)uint64",
            "args": method_args,
        }))

    def buy_ticket(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | BuyTicketArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "buy_ticket(uint64,pay)uint64",
            "args": method_args,
        }))

    def verify_ticket(
        self,
        args: tuple[int, str | bytes] | VerifyTicketArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "verify_ticket(uint64,account)bool",
            "args": method_args,
        }))

    def get_event_details(
        self,
        args: tuple[int] | GetEventDetailsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_event_details(uint64)(byte[],byte[],byte[],uint64,uint64,uint64,uint64,uint64)",
            "args": method_args,
        }))

    def get_club_name(
        self,
        args: tuple[bytes | str] | GetClubNameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_club_name(byte[])byte[]",
            "args": method_args,
        }))

    def get_total_events(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
    
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_total_events()uint64",
        }))

    def is_club_registered(
        self,
        args: tuple[str | bytes] | IsClubRegisteredArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "is_club_registered(account)bool",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class TicketingPlatformSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def register_club(
        self,
        args: tuple[str, str] | RegisterClubArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[str]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "register_club(string,string)string",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[str], parsed_response)

    def create_event(
        self,
        args: tuple[str, str, int, int, int] | CreateEventArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_event(string,string,uint64,uint64,uint64)uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def buy_ticket(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | BuyTicketArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "buy_ticket(uint64,pay)uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def verify_ticket(
        self,
        args: tuple[int, str | bytes] | VerifyTicketArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bool]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "verify_ticket(uint64,account)bool",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bool], parsed_response)

    def get_event_details(
        self,
        args: tuple[int] | GetEventDetailsArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[tuple[bytes, bytes, bytes, int, int, int, int, int]]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_event_details(uint64)(byte[],byte[],byte[],uint64,uint64,uint64,uint64,uint64)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[tuple[bytes, bytes, bytes, int, int, int, int, int]], parsed_response)

    def get_club_name(
        self,
        args: tuple[bytes | str] | GetClubNameArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bytes]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_club_name(byte[])byte[]",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bytes], parsed_response)

    def get_total_events(
        self,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
    
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_total_events()uint64",
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def is_club_registered(
        self,
        args: tuple[str | bytes] | IsClubRegisteredArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bool]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "is_club_registered(account)bool",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bool], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class GlobalStateValue(typing.TypedDict):
    """Shape of global_state state key values"""
    event_counter: int

class TicketingPlatformState:
    """Methods to access state for the current TicketingPlatform app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def global_state(
        self
    ) -> "_GlobalState":
            """Methods to access global_state for the current app"""
            return _GlobalState(self.app_client)

    @property
    def box(
        self
    ) -> "_BoxState":
            """Methods to access box for the current app"""
            return _BoxState(self.app_client)

class _GlobalState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> GlobalStateValue:
        """Get all current keyed values from global_state state"""
        result = self.app_client.state.global_state.get_all()
        if not result:
            return typing.cast(GlobalStateValue, {})

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.global_state.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return typing.cast(GlobalStateValue, converted)

    @property
    def event_counter(self) -> int:
        """Get the current value of the event_counter key in global_state state"""
        value = self.app_client.state.global_state.get_value("event_counter")
        if isinstance(value, dict) and "AVMUint64" in self._struct_classes:
            return _init_dataclass(self._struct_classes["AVMUint64"], value)  # type: ignore
        return typing.cast(int, value)

class _BoxState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {}

    def get_all(self) -> dict[str, typing.Any]:
        """Get all current keyed values from box state"""
        result = self.app_client.state.box.get_all()
        if not result:
            return {}

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.box.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return converted

    @property
    def club_names(self) -> "_MapState[str, bytes]":
        """Get values from the club_names map in box state"""
        return _MapState(
            self.app_client.state.box,
            "club_names",
            None
        )

    @property
    def event_clubs(self) -> "_MapState[int, str]":
        """Get values from the event_clubs map in box state"""
        return _MapState(
            self.app_client.state.box,
            "event_clubs",
            None
        )

    @property
    def event_names(self) -> "_MapState[int, bytes]":
        """Get values from the event_names map in box state"""
        return _MapState(
            self.app_client.state.box,
            "event_names",
            None
        )

    @property
    def event_venues(self) -> "_MapState[int, bytes]":
        """Get values from the event_venues map in box state"""
        return _MapState(
            self.app_client.state.box,
            "event_venues",
            None
        )

    @property
    def event_dates(self) -> "_MapState[int, int]":
        """Get values from the event_dates map in box state"""
        return _MapState(
            self.app_client.state.box,
            "event_dates",
            None
        )

    @property
    def event_prices(self) -> "_MapState[int, int]":
        """Get values from the event_prices map in box state"""
        return _MapState(
            self.app_client.state.box,
            "event_prices",
            None
        )

    @property
    def event_total(self) -> "_MapState[int, int]":
        """Get values from the event_total map in box state"""
        return _MapState(
            self.app_client.state.box,
            "event_total",
            None
        )

    @property
    def event_sold(self) -> "_MapState[int, int]":
        """Get values from the event_sold map in box state"""
        return _MapState(
            self.app_client.state.box,
            "event_sold",
            None
        )

    @property
    def event_assets(self) -> "_MapState[int, int]":
        """Get values from the event_assets map in box state"""
        return _MapState(
            self.app_client.state.box,
            "event_assets",
            None
        )

_KeyType = typing.TypeVar("_KeyType")
_ValueType = typing.TypeVar("_ValueType")

class _AppClientStateMethodsProtocol(typing.Protocol):
    def get_map(self, map_name: str) -> dict[typing.Any, typing.Any]:
        ...
    def get_map_value(self, map_name: str, key: typing.Any) -> typing.Any | None:
        ...

class _MapState(typing.Generic[_KeyType, _ValueType]):
    """Generic class for accessing state maps with strongly typed keys and values"""

    def __init__(self, state_accessor: _AppClientStateMethodsProtocol, map_name: str,
                struct_class: typing.Type[_ValueType] | None = None):
        self._state_accessor = state_accessor
        self._map_name = map_name
        self._struct_class = struct_class

    def get_map(self) -> dict[_KeyType, _ValueType]:
        """Get all current values in the map"""
        result = self._state_accessor.get_map(self._map_name)
        if self._struct_class and result:
            return {k: _init_dataclass(self._struct_class, v) if isinstance(v, dict) else v
                    for k, v in result.items()}  # type: ignore
        return typing.cast(dict[_KeyType, _ValueType], result or {})

    def get_value(self, key: _KeyType) -> _ValueType | None:
        """Get a value from the map by key"""
        key_value = dataclasses.asdict(key) if dataclasses.is_dataclass(key) else key  # type: ignore
        value = self._state_accessor.get_map_value(self._map_name, key_value)
        if value is not None and self._struct_class and isinstance(value, dict):
            return _init_dataclass(self._struct_class, value)  # type: ignore
        return typing.cast(_ValueType | None, value)


class TicketingPlatformClient:
    """Client for interacting with TicketingPlatform smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = TicketingPlatformParams(self.app_client)
        self.create_transaction = TicketingPlatformCreateTransactionParams(self.app_client)
        self.send = TicketingPlatformSend(self.app_client)
        self.state = TicketingPlatformState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "TicketingPlatformClient":
        return TicketingPlatformClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "TicketingPlatformClient":
        return TicketingPlatformClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "TicketingPlatformClient":
        return TicketingPlatformClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "TicketingPlatformComposer":
        return TicketingPlatformComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["register_club(string,string)string"],
        return_value: algokit_utils.ABIReturn | None
    ) -> str | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["create_event(string,string,uint64,uint64,uint64)uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["buy_ticket(uint64,pay)uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["verify_ticket(uint64,account)bool"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bool | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_event_details(uint64)(byte[],byte[],byte[],uint64,uint64,uint64,uint64,uint64)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> tuple[bytes, bytes, bytes, int, int, int, int, int] | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_club_name(byte[])byte[]"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bytes | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_total_events()uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["is_club_registered(account)bool"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bool | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None | bool | bytes | int | str | tuple[bytes, bytes, bytes, int, int, int, int, int]:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class TicketingPlatformBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):
    """Parameters for creating TicketingPlatform contract with bare calls"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:
        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)

class TicketingPlatformFactory(algokit_utils.TypedAppFactoryProtocol[TicketingPlatformBareCallCreateParams, None, None]):
    """Factory for deploying and managing TicketingPlatformClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = TicketingPlatformFactoryParams(self.app_factory)
        self.create_transaction = TicketingPlatformFactoryCreateTransaction(self.app_factory)
        self.send = TicketingPlatformFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: TicketingPlatformBareCallCreateParams | None = None,
        update_params: None = None,
        delete_params: None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[TicketingPlatformClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return TicketingPlatformClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> TicketingPlatformClient:
        """Get an app client by creator address and name"""
        return TicketingPlatformClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> TicketingPlatformClient:
        """Get an app client by app ID"""
        return TicketingPlatformClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class TicketingPlatformFactoryParams:
    """Parameters for creating transactions for TicketingPlatform contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = TicketingPlatformFactoryCreateParams(app_factory)
        self.update = TicketingPlatformFactoryUpdateParams(app_factory)
        self.delete = TicketingPlatformFactoryDeleteParams(app_factory)

class TicketingPlatformFactoryCreateParams:
    """Parameters for 'create' operations of TicketingPlatform contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def register_club(
        self,
        args: tuple[str, str] | RegisterClubArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the register_club(string,string)string ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "register_club(string,string)string",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def create_event(
        self,
        args: tuple[str, str, int, int, int] | CreateEventArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the create_event(string,string,uint64,uint64,uint64)uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "create_event(string,string,uint64,uint64,uint64)uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def buy_ticket(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | BuyTicketArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the buy_ticket(uint64,pay)uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "buy_ticket(uint64,pay)uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def verify_ticket(
        self,
        args: tuple[int, str | bytes] | VerifyTicketArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the verify_ticket(uint64,account)bool ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "verify_ticket(uint64,account)bool",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def get_event_details(
        self,
        args: tuple[int] | GetEventDetailsArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_event_details(uint64)(byte[],byte[],byte[],uint64,uint64,uint64,uint64,uint64) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_event_details(uint64)(byte[],byte[],byte[],uint64,uint64,uint64,uint64,uint64)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def get_club_name(
        self,
        args: tuple[bytes | str] | GetClubNameArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_club_name(byte[])byte[] ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_club_name(byte[])byte[]",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def get_total_events(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_total_events()uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_total_events()uint64",
                "args": None,
                }
            ),
            compilation_params=compilation_params
        )

    def is_club_registered(
        self,
        args: tuple[str | bytes] | IsClubRegisteredArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the is_club_registered(account)bool ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "is_club_registered(account)bool",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

class TicketingPlatformFactoryUpdateParams:
    """Parameters for 'update' operations of TicketingPlatform contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class TicketingPlatformFactoryDeleteParams:
    """Parameters for 'delete' operations of TicketingPlatform contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class TicketingPlatformFactoryCreateTransaction:
    """Create transactions for TicketingPlatform contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = TicketingPlatformFactoryCreateTransactionCreate(app_factory)


class TicketingPlatformFactoryCreateTransactionCreate:
    """Create new instances of TicketingPlatform contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class TicketingPlatformFactorySend:
    """Send calls to TicketingPlatform contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = TicketingPlatformFactorySendCreate(app_factory)


class TicketingPlatformFactorySendCreate:
    """Send create calls to TicketingPlatform contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[TicketingPlatformClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return TicketingPlatformClient(result[0]), result[1]


class TicketingPlatformComposer:
    """Composer for creating transaction groups for TicketingPlatform contract calls"""

    def __init__(self, client: "TicketingPlatformClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    def register_club(
        self,
        args: tuple[str, str] | RegisterClubArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "TicketingPlatformComposer":
        self._composer.add_app_call_method_call(
            self.client.params.register_club(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "register_club(string,string)string", v
            )
        )
        return self

    def create_event(
        self,
        args: tuple[str, str, int, int, int] | CreateEventArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "TicketingPlatformComposer":
        self._composer.add_app_call_method_call(
            self.client.params.create_event(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "create_event(string,string,uint64,uint64,uint64)uint64", v
            )
        )
        return self

    def buy_ticket(
        self,
        args: tuple[int, algokit_utils.AppMethodCallTransactionArgument] | BuyTicketArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "TicketingPlatformComposer":
        self._composer.add_app_call_method_call(
            self.client.params.buy_ticket(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "buy_ticket(uint64,pay)uint64", v
            )
        )
        return self

    def verify_ticket(
        self,
        args: tuple[int, str | bytes] | VerifyTicketArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "TicketingPlatformComposer":
        self._composer.add_app_call_method_call(
            self.client.params.verify_ticket(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "verify_ticket(uint64,account)bool", v
            )
        )
        return self

    def get_event_details(
        self,
        args: tuple[int] | GetEventDetailsArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "TicketingPlatformComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_event_details(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_event_details(uint64)(byte[],byte[],byte[],uint64,uint64,uint64,uint64,uint64)", v
            )
        )
        return self

    def get_club_name(
        self,
        args: tuple[bytes | str] | GetClubNameArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "TicketingPlatformComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_club_name(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_club_name(byte[])byte[]", v
            )
        )
        return self

    def get_total_events(
        self,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "TicketingPlatformComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_total_events(
                
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_total_events()uint64", v
            )
        )
        return self

    def is_club_registered(
        self,
        args: tuple[str | bytes] | IsClubRegisteredArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "TicketingPlatformComposer":
        self._composer.add_app_call_method_call(
            self.client.params.is_club_registered(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "is_club_registered(account)bool", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "TicketingPlatformComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "TicketingPlatformComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)
